<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>How do I save a stream to a file in C#? - WeBlogy</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content="I have a StreamReader object that I initialized with a stream, now I want to save this stream to disk (the stream may be a .gif or .jpg or .pdf). Existing Code: I have the encoding type also, which I will need if I store it to SQL Server, correct?"><meta name=robots content="index,follow,noarchive"><meta property="og:title" content="How do I save a stream to a file in C#?"><meta property="og:description" content="I have a StreamReader object that I initialized with a stream, now I want to save this stream to disk (the stream may be a .gif or .jpg or .pdf). Existing Code: I have the encoding type also, which I will need if I store it to SQL Server, correct?"><meta property="og:type" content="article"><meta property="og:url" content="/how-do-i-save-a-stream-to-a-file-in-c.html"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-08-29T00:00:00+00:00"><meta property="article:modified_time" content="2024-08-29T00:00:00+00:00"><meta itemprop=name content="How do I save a stream to a file in C#?"><meta itemprop=description content="I have a StreamReader object that I initialized with a stream, now I want to save this stream to disk (the stream may be a .gif or .jpg or .pdf). Existing Code: I have the encoding type also, which I will need if I store it to SQL Server, correct?"><meta itemprop=datePublished content="2024-08-29T00:00:00+00:00"><meta itemprop=dateModified content="2024-08-29T00:00:00+00:00"><meta itemprop=wordCount content="1554"><meta itemprop=keywords content><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=https://assets.cdnweb.info/hugo/mainroad/css/style.css><link rel="shortcut icon" href=./favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=./index.html title=WeBlogy rel=home><div class="logo__item logo__text"><div class=logo__title>WeBlogy</div></div></a></div><div class=divider></div></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>How do I save a stream to a file in C#?</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2024-08-29T00:00:00Z>August 29, 2024</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=./categories/blog/ rel=category>blog</a></span></div></div></header><div class="content post__content clearfix"><img src=https://cdn.statically.io/img/cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto><p>I have a <code>StreamReader</code> object that I initialized with a stream, now I want to save this stream to disk (the stream may be a <code>.gif</code> or <code>.jpg</code> or <code>.pdf</code>).</p><p>Existing Code:</p><pre><code>StreamReader sr = new StreamReader(myOtherObject.InputStream); </code></pre><li>I need to save this to disk (I have the filename).</li><li>In the future I may want to store this to SQL Server.</li><p>I have the encoding type also, which I will need if I store it to SQL Server, correct?</p><span class=d-none itemprop=commentCount>1</span><h2 class=mb0 data-answercount=10>10 Answers</h2><p>As highlighted by Tilendor in Jon Skeet's answer, streams have a <code>CopyTo</code> method since .NET 4.</p><pre><code>var fileStream = File.Create("C:\\Path\\To\\File"); myOtherObject.InputStream.Seek(0, SeekOrigin.Begin); myOtherObject.InputStream.CopyTo(fileStream); fileStream.Close(); </code></pre><p>Or with the <code>using</code> syntax:</p><pre><code>using (var fileStream = File.Create("C:\\Path\\To\\File")) { myOtherObject.InputStream.Seek(0, SeekOrigin.Begin); myOtherObject.InputStream.CopyTo(fileStream); } </code></pre><span class=d-none itemprop=commentCount>7</span><p>You must not use <code>StreamReader</code> for binary files (like gifs or jpgs). <code>StreamReader</code> is for text data. You will almost certainly lose data if you use it for arbitrary binary data. (If you use Encoding.GetEncoding(28591) you will probably be okay, but what's the point?)</p><p>Why do you need to use a <code>StreamReader</code> at all? Why not just keep the binary data as binary data and write it back to disk (or SQL) as binary data?</p><p>EDIT: As this seems to be something people want to see... if you do just want to copy one stream to another (e.g. to a file) use something like this:</p><pre><code>/// &lt;summary&gt; /// Copies the contents of input to output. Doesn't close either stream. /// &lt;/summary&gt; public static void CopyStream(Stream input, Stream output) { byte[] buffer = new byte[8 * 1024]; int len; while ( (len = input.Read(buffer, 0, buffer.Length)) &gt; 0) { output.Write(buffer, 0, len); } } </code></pre><p>To use it to dump a stream to a file, for example:</p><pre><code>using (Stream file = File.Create(filename)) { CopyStream(input, file); } </code></pre><p>Note that <a href=# rel=noreferrer><code>Stream.CopyTo</code></a> was introduced in .NET 4, serving basically the same purpose.</p><span class=d-none itemprop=commentCount>8</span><pre><code>public void CopyStream(Stream stream, string destPath) { using (var fileStream = new FileStream(destPath, FileMode.Create, FileAccess.Write)) { stream.CopyTo(fileStream); } } </code></pre><span class=d-none itemprop=commentCount>4</span><pre><code>private void SaveFileStream(String path, Stream stream) { var fileStream = new FileStream(path, FileMode.Create, FileAccess.Write); stream.CopyTo(fileStream); fileStream.Dispose(); } </code></pre><span class=d-none itemprop=commentCount>3</span><p>I don't get all of the answers using <code>CopyTo</code>, where maybe the systems using the app might not have been upgraded to .NET 4.0+. I know some would like to force people to upgrade, but compatibility is also nice, too.</p><p>Another thing, I don't get using a stream to copy from another stream in the first place. Why not just do:</p><pre><code>byte[] bytes = myOtherObject.InputStream.ToArray(); </code></pre><p>Once you have the bytes, you can easily write them to a file:</p><pre><code>public static void WriteFile(string fileName, byte[] bytes) { string path = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location); if (!path.EndsWith(@"\")) path += @"\"; if (File.Exists(Path.Combine(path, fileName))) File.Delete(Path.Combine(path, fileName)); using (FileStream fs = new FileStream(Path.Combine(path, fileName), FileMode.CreateNew, FileAccess.Write)) { fs.Write(bytes, 0, (int)bytes.Length); //fs.Close(); } } </code></pre><p>This code works as I've tested it with a <code>.jpg</code> file, though I admit I have only used it with small files (less than 1 MB). One stream, no copying between streams, no encoding needed, just write the bytes! No need to over-complicate things with <code>StreamReader</code> if you already have a stream you can convert to <code>bytes</code> directly with <code>.ToArray()</code>!</p><p>Only potential downsides I can see in doing it this way is if there's a large file you have, having it as a stream and using <code>.CopyTo()</code> or equivalent allows <code>FileStream</code> to stream it instead of using a byte array and reading the bytes one by one. It might be slower doing it this way, as a result. But it shouldn't choke since the <code>.Write()</code> method of the <code>FileStream</code> handles writing the bytes, and it's only doing it one byte at a time, so it won't clog memory, except that <strong>you will have to have enough memory to hold the stream as a <code>byte[]</code> object</strong>. In my situation where I used this, getting an <code>OracleBlob</code>, I had to go to a <code>byte[]</code>, it was small enough, and besides, there was no streaming available to me, anyway, so I just sent my bytes to my function, above.</p><p>Another option, using a stream, would be to use it with Jon Skeet's <code>CopyStream</code> function that was in another post - this just uses <code>FileStream</code> to take the input stream and create the file from it directly. It does not use <code>File.Create</code>, like he did (which initially seemed to be problematic for me, but later found it was likely just a VS bug...).</p><pre><code>/// &lt;summary&gt; /// Copies the contents of input to output. Doesn't close either stream. /// &lt;/summary&gt; public static void CopyStream(Stream input, Stream output) { byte[] buffer = new byte[8 * 1024]; int len; while ( (len = input.Read(buffer, 0, buffer.Length)) &gt; 0) { output.Write(buffer, 0, len); } } public static void WriteFile(string fileName, Stream inputStream) { string path = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location); if (!path.EndsWith(@"\")) path += @"\"; if (File.Exists(Path.Combine(path, fileName))) File.Delete(Path.Combine(path, fileName)); using (FileStream fs = new FileStream(Path.Combine(path, fileName), FileMode.CreateNew, FileAccess.Write) { CopyStream(inputStream, fs); } inputStream.Close(); inputStream.Flush(); } </code></pre><span class=d-none itemprop=commentCount>4</span><p>Here's an example that uses proper usings and implementation of idisposable:</p><pre><code>static void WriteToFile(string sourceFile, string destinationfile, bool append = true, int bufferSize = 4096) { using (var sourceFileStream = new FileStream(sourceFile, FileMode.OpenOrCreate)) { using (var destinationFileStream = new FileStream(destinationfile, FileMode.OpenOrCreate)) { while (sourceFileStream.Position &lt; sourceFileStream.Length) { destinationFileStream.WriteByte((byte)sourceFileStream.ReadByte()); } } } } </code></pre><p>...and there's also this</p><pre><code> public static void WriteToFile(Stream stream, string destinationFile, int bufferSize = 4096, FileMode mode = FileMode.OpenOrCreate, FileAccess access = FileAccess.ReadWrite, FileShare share = FileShare.ReadWrite) { using (var destinationFileStream = new FileStream(destinationFile, mode, access, share)) { while (stream.Position &lt; stream.Length) { destinationFileStream.WriteByte((byte)stream.ReadByte()); } } } </code></pre><p>The key is understanding the proper use of using (which should be implemented on the instantiation of the object that implements idisposable as shown above), and having a good idea as to how the properties work for streams. Position is literally the index within the stream (which starts at 0) that is followed as each byte is read using the readbyte method. In this case I am essentially using it in place of a for loop variable and simply letting it follow through all the way up to the length which is LITERALLY the end of the entire stream (in bytes). Ignore in bytes because it is practically the same and you will have something simple and elegant like this that resolves everything cleanly.</p><p>Keep in mind, too, that the ReadByte method simply casts the byte to an int in the process and can simply be converted back.</p><p>I'm gonna add another implementation I recently wrote to create a dynamic buffer of sorts to ensure sequential data writes to prevent massive overload</p><pre><code>private void StreamBuffer(Stream stream, int buffer) { using (var memoryStream = new MemoryStream()) { stream.CopyTo(memoryStream); var memoryBuffer = memoryStream.GetBuffer(); for (int i = 0; i &lt; memoryBuffer.Length;) { var networkBuffer = new byte[buffer]; for (int j = 0; j &lt; networkBuffer.Length &amp;&amp; i &lt; memoryBuffer.Length; j++) { networkBuffer[j] = memoryBuffer[i]; i++; } //Assuming destination file destinationFileStream.Write(networkBuffer, 0, networkBuffer.Length); } } } </code></pre><p>The explanation is fairly simple: we know that we need to keep in mind the entire set of data we wish to write and also that we only want to write certain amounts, so we want the first loop with the last parameter empty (same as while). Next, we initialize a byte array buffer that is set to the size of what's passed, and with the second loop we compare j to the size of the buffer and the size of the original one, and if it's greater than the size of the original byte array, end the run.</p><span class=d-none itemprop=commentCount>1</span><p>Why not use a FileStream object?</p><pre><code>public void SaveStreamToFile(string fileFullPath, Stream stream) { if (stream.Length == 0) return; // Create a FileStream object to write a stream to a file using (FileStream fileStream = System.IO.File.Create(fileFullPath, (int)stream.Length)) { // Fill the bytes[] array with the stream data byte[] bytesInStream = new byte[stream.Length]; stream.Read(bytesInStream, 0, (int)bytesInStream.Length); // Use FileStream object to write to the specified file fileStream.Write(bytesInStream, 0, bytesInStream.Length); } } </code></pre><span class=d-none itemprop=commentCount>4</span><pre><code>//If you don't have .Net 4.0 :) public void SaveStreamToFile(Stream stream, string filename) { using(Stream destination = File.Create(filename)) Write(stream, destination); } //Typically I implement this Write method as a Stream extension method. //The framework handles buffering. public void Write(Stream from, Stream to) { for(int a = from.ReadByte(); a != -1; a = from.ReadByte()) to.WriteByte( (byte) a ); } /* Note, StreamReader is an IEnumerable&lt;Char&gt; while Stream is an IEnumbable&lt;byte&gt;. The distinction is significant such as in multiple byte character encodings like Unicode used in .Net where Char is one or more bytes (byte[n]). Also, the resulting translation from IEnumerable&lt;byte&gt; to IEnumerable&lt;Char&gt; can loose bytes or insert them (for example, "\n" vs. "\r\n") depending on the StreamReader instance CurrentEncoding. */ </code></pre><span class=d-none itemprop=commentCount>1</span><p>Another option is to get the stream to a <code>byte[]</code> and use <code>File.WriteAllBytes</code>. This should do:</p><pre><code>using (var stream = new MemoryStream()) { input.CopyTo(stream); File.WriteAllBytes(file, stream.ToArray()); } </code></pre><p>Wrapping it in an extension method gives it better naming:</p><pre><code>public void WriteTo(this Stream input, string file) { //your fav write method: using (var stream = File.Create(file)) { input.CopyTo(stream); } //or using (var stream = new MemoryStream()) { input.CopyTo(stream); File.WriteAllBytes(file, stream.ToArray()); } //whatever that fits. } </code></pre><span class=d-none itemprop=commentCount>1</span><pre><code>public void testdownload(stream input) { byte[] buffer = new byte[16345]; using (FileStream fs = new FileStream(this.FullLocalFilePath, FileMode.Create, FileAccess.Write, FileShare.None)) { int read; while ((read = input.Read(buffer, 0, buffer.Length)) &gt; 0) { fs.Write(buffer, 0, read); } } } </code></pre><span class=d-none itemprop=commentCount>2</span><p class=postsid style=color:rgba(255,0,0,0)>ncG1vNJzZmirpJawrLvVnqmfpJ%2Bse6S7zGiorp2jqbawutJoa2ppZW5%2FcLTOsGSdp12eerSt1Z5kmmWjqb%2Bmrcxmq6hlkWKzqrjEZqCnZZM%3D</p></div></article></main><nav class="pager flex"><div class="pager__item pager__item--prev"><a class=pager__link href=./liza-todd.html rel=prev><span class=pager__subtitle>«&#8201;Previous</span><p class=pager__title>Liza Todd</p></a></div><div class="pager__item pager__item--next"><a class=pager__link href=./a-jay-popoff-2.html rel=next><span class=pager__subtitle>Next&#8201;»</span><p class=pager__title>A. Jay Popoff</p></a></div></nav></div><aside class=sidebar><div class="widget-recent widget"><h4 class=widget__title>Recent Posts</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=./ha-young-choi.html>Ha Young Choi</a></li><li class=widget__item><a class=widget__link href=./johnny-depp-clean-shaven-makeover-nyc-before-after-photos.html>Before &amp;amp; After Pics Hollywood Life</a></li><li class=widget__item><a class=widget__link href=./brittany-renner-viral-video-scandal-telegram.html>Brittany Renner Viral Video Leaked Footage Scandal On Telegram 2023</a></li><li class=widget__item><a class=widget__link href=./patrick-mahomes-2.html>Patrick Mahomes Age, Net Worth, Wife, Family &amp;amp; Biography</a></li><li class=widget__item><a class=widget__link href=./suzanne-somers-74-dishes-she-and-husband-alan-hamel-84-have-been-having-a-lot-of-sex.html>Suzanne Somers, 74, dishes she and husband Alan Hamel, 84, have been 'having a lot of sex'</a></li></ul></div></div><div class="widget-categories widget"><h4 class=widget__title>Categories</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=./categories/blog/>blog</a></li></ul></div></div></aside></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2024 WeBlogy.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=https://assets.cdnweb.info/hugo/mainroad/js/menu.js></script>
<script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://iklan.listspress.com/floating.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://iklan.listspress.com/tracking_server_6.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script>var _paq=window._paq=window._paq||[];_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){e="//analytics.cdnweb.info/",_paq.push(["setTrackerUrl",e+"matomo.php"]),_paq.push(["setSiteId","1"]);var e,n=document,t=n.createElement("script"),s=n.getElementsByTagName("script")[0];t.async=!0,t.src=e+"matomo.js",s.parentNode.insertBefore(t,s)}()</script></body></html>